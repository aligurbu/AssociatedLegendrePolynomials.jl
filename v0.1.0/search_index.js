var documenterSearchIndex = {"docs":
[{"location":"lib/private/#Private-Documentation-1","page":"Private","title":"Private Documentation","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [Legendre]\nPublic = false","category":"page"},{"location":"lib/private/#Legendre.Plm_00","page":"Private","title":"Legendre.Plm_00","text":"Plm_00(::N, ::Type{T}) where {N<:AbstractLegendreNorm, T}\n\nReturns the initial condition P_0^0(x) for the associated Legendre recursions based on the normalization choice N for numeric type T.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#Legendre.Plm_α","page":"Private","title":"Legendre.Plm_α","text":"Plm_α(norm::N, ::Type{T}, l::Integer, m::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient α_ℓ^m for the two-term recursion relation\n\n    P_ℓ+1^m(x) = α_ℓ+1^m x P_ℓ^m(x) - β_ℓ+1^m P_ℓ-1^m(x)\n\nwhere α_ℓ^m is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#Legendre.Plm_β","page":"Private","title":"Legendre.Plm_β","text":"Plm_β(norm::N, ::Type{T}, l::Integer, m::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient β_ℓ^m for the two-term recursion relation\n\n    P_ℓ+1^m(x) = α_ℓ+1^m x P_ℓ^m(x) - β_ℓ+1^m P_ℓ-1^m(x)\n\nwhere β_ℓ^m is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#Legendre.Plm_μ","page":"Private","title":"Legendre.Plm_μ","text":"Plm_μ(norm::N, ::Type{T}, l::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient μ_ℓ for the single-term recursion relation\n\n    P_ℓ+1^ℓ+1(x) = -μ_ℓ+1 sqrt1-x^2 P_ℓ^ℓ(x)\n\nwhere μ_ℓ is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#Legendre.Plm_ν","page":"Private","title":"Legendre.Plm_ν","text":"Plm_ν(norm::N, ::Type{T}, l::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient ν_ℓ for the single-term recursion relation\n\n    P_ℓ+1^ℓ(x) = ν_ℓ+1 x P_ℓ^ℓ(x)\n\nwhere ν_ℓ is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"man/references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/#bib-legendre-1","page":"References","title":"Legendre functions","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"T. Limpanuparb and J. Milthorpe. “Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications” In: Proceedings of the 40th Congress on Science and Technology of Thailand (Dec 2014) arXiv: 1410.1748\n“Legendre polynomials” on Wikipedia and Wolfram Math World\n“Associated Legendre polynomials” on Wikipedia and Wolfrm Math World","category":"page"},{"location":"lib/public/#Public-Documentation-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [Legendre]\nPrivate = false","category":"page"},{"location":"lib/public/#Legendre.Legendre","page":"Public","title":"Legendre.Legendre","text":"Collections of functions which compute the associated Legendre functions.\n\nBased on implementation described in Limpanuparb and Milthorpe (2014) “Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications” arXiv:1410.1748v1\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#Legendre.AbstractLegendreNorm","page":"Public","title":"Legendre.AbstractLegendreNorm","text":"abstract type AbstractLegendreNorm end\n\nAbstract trait supertype for normalization conditions of the Associated Legendre polynomials.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Legendre.LegendreNormCoeff","page":"Public","title":"Legendre.LegendreNormCoeff","text":"struct LegendreNormCoeff{N<:AbstractLegendreNorm,T<:Real} <: AbstractLegendreNorm\n\nPrecomputed recursion relation coefficients for the normalization N and value type T.\n\nExample\n\njulia> LegendreNormCoeff{LegendreSphereNorm,Float64}(1)\nLegendreNormCoeff{LegendreSphereNorm,Float64} for lmax = 1, mmax = 1 with coefficients:\n    μ: [0.0, 1.22474]\n    ν: [1.73205, 2.23607]\n    α: [0.0 0.0; 1.73205 0.0]\n    β: [0.0 0.0; -0.0 0.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Legendre.LegendreSphereCoeff","page":"Public","title":"Legendre.LegendreSphereCoeff","text":"LegendreSphereCoeff{T}\n\nTable type of precomputed recursion relation coefficients for the spherical harmonic normalization. Alias for LegendreNormCoeff{LegendreSphereNorm,T}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Legendre.LegendreSphereNorm","page":"Public","title":"Legendre.LegendreSphereNorm","text":"struct LegendreSphereNorm <: AbstractLegendreNorm end\n\nTrait type denoting the spherical-harmonic normalization of the associated Legendre polynomials.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Legendre.LegendreUnitCoeff","page":"Public","title":"Legendre.LegendreUnitCoeff","text":"LegendreUnitCoeff{T}\n\nPrecomputed recursion relation coefficients for the standard unit normalization. Alias for LegendreNormCoeff{LegendreUnitNorm,T}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Legendre.LegendreUnitNorm","page":"Public","title":"Legendre.LegendreUnitNorm","text":"struct LegendreUnitNorm <: AbstractLegendreNorm end\n\nTrait type denoting the unit normalization of the associated Legendre polynomials.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T","page":"Public","title":"Legendre.Nlm","text":"N = Nlm([T=Float64], l, m)\n\nComputes the normalization constant\n\n    N_ℓ^m  sqrtfrac2ℓ+14π frac(ℓ-m)(ℓ+m)\n\nwhich defines the Spherical Harmonic normalized functions λ_ℓ^m(x) in terms of the standard unit normalized P_ℓ^m(x)\n\n    λ_ℓ^m(x)  N_ℓ^m P_ℓ^m(x)\n\nusing numbers of type T.\n\nSee also Plm and λlm.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.Pl!-Tuple{Any,Integer,Any}","page":"Public","title":"Legendre.Pl!","text":"Pl!(P, l::Integer, x)\n\nFills the array P with the unit-normalized Legendre polynomial values P_ℓ(x) for fixed order m = 0; equivalent to legendre!(LegendreUnitNorm(), P, l, 0, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.Pl-Tuple{Integer,Number}","page":"Public","title":"Legendre.Pl","text":"p = Pl(l::Integer, x::Number)\n\nComputes the Legendre polynomials using unit normalization and for degree m = 0; equivalent to p = legendre(LegendreUnitNorm(), l, 0, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.Plm!-Tuple{Any,Integer,Integer,Any}","page":"Public","title":"Legendre.Plm!","text":"Plm!(P, l::Integer, m::Integer, x)\n\nFills the array P with the unit-normalized associated Legendre polynomial values P_ℓ^m(x); equivalent to legendre!(LegendreUnitNorm(), P, l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.Plm-Tuple{Integer,Integer,Number}","page":"Public","title":"Legendre.Plm","text":"p = Plm(l::Integer, m::Integer, x::Number)\n\nComputes the associated Legendre polynomials using unit normalization; equivalent to p = legendre(LegendreUnitNorm(), l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.legendre!-Tuple{AbstractLegendreNorm,Any,Integer,Integer,Any}","page":"Public","title":"Legendre.legendre!","text":"legendre!(norm::AbstractLegendreNorm, Λ, l::Integer, m::Integer, x)\n\nFills the array Λ with the Legendre polynomial values N_ℓ^m P_ℓ^m(x) up to/of degree l and order m for the normalization scheme norm. Λ must be an array with between 0 and 2 more dimensions than x, with the leading dimensions having the same shape as x.\n\nIf ndims(Λ) == ndims(x), then Λ is filled with the polynomial values at x for degree l and order m.\nIf ndims(Λ) == ndims(x) + 1, then l is interpreted as lmax, and Λ filled with polynomial values for all degrees 0 ≤ l ≤ lmax of order m.\nIf ndims(Λ) == ndims(x) + 2, then l is interpreted as lmax and m as mmax, and Λ is filled with polynomial values for all degrees 0 ≤ l ≤ lmax and orders 0 ≤ m ≤ min(mmax, l).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Number}","page":"Public","title":"Legendre.legendre","text":"p = legendre(norm::AbstractLegendreNorm, l::Integer, m::Integer, x::Number)\nP = legendre.(norm::AbstractLegendreNorm, l, m, x)\n\nComputes the associated Legendre polynomial N_ℓ^m P_ℓ^m(x) of degree l and order m at x for the normalization scheme norm.\n\nWith broadcasting syntax, the polynomials can be computed over any iterable x. Furthermore,\n\nIf l isa Integer && m isa Integer, then the output P has the same shape as x and is filled with the polynomial values of order l and degree m.\nIf l isa UnitRange && m isa Integer, then l is interpreted as lmax, and the output P has one more dimension than x with the trailing dimension spanning the degrees 0 ≤ l ≤ lmax.\nIf l isa UnitRange && m isa UnitRange, then l is interpreted as lmax and m as mmax, and the output P has two more dimensions than x with the trailing dimensions spanning the degrees 0 ≤ l ≤ lmax and orders 0 ≤ m ≤ mmax, respectively.\n\nNote that in second and third case, the UnitRanges must satisify first(l) == 0 and first(m) == 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Number}","page":"Public","title":"Legendre.legendre","text":"p = legendre(norm::AbstractLegendreNorm, l::Integer, x::Number)\nP = legendre.(norm::AbstractLegendreNorm, l, x)\n\nComputes the associated Legendre polynomial assuming the order m = 0; equivalent to legendre(norm, l, 0, x) and legendre.(norm, l, 0, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.λlm!-Tuple{Any,Integer,Integer,Any}","page":"Public","title":"Legendre.λlm!","text":"λlm!(Λ, l::Integer, m::Integer, x)\n\nFills the array Λ with the spherical-harmonic normalized associated Legendre polynomial values λ_ℓ^m(x); equivalent to legendre!(LegendreSphereNorm(), P, l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre.λlm-Tuple{Integer,Integer,Number}","page":"Public","title":"Legendre.λlm","text":"λ = λlm(l::Integer, m::Integer, x::Number)\n\nComputes the associated Legendre polynomials using spherical-harmonic normalization; equivalent to λ = legendre(LegendreSphereNorm(), l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"#Legendre.jl-Documentation-1","page":"Legendre.jl Documentation","title":"Legendre.jl Documentation","text":"","category":"section"},{"location":"#","page":"Legendre.jl Documentation","title":"Legendre.jl Documentation","text":"A library for calculating the Associated Legendre polynomials. Design goals of this package include:","category":"page"},{"location":"#","page":"Legendre.jl Documentation","title":"Legendre.jl Documentation","text":"Native Julia implementation of core routines.\nNumerical stability and efficiency.\nParallelism and efficient memory sharing.","category":"page"},{"location":"#User-Manual-and-Documentation-1","page":"Legendre.jl Documentation","title":"User Manual and Documentation","text":"","category":"section"},{"location":"#","page":"Legendre.jl Documentation","title":"Legendre.jl Documentation","text":"Pages = [\n    \"man/legendre.md\",\n    \"man/references.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-API-Reference-1","page":"Legendre.jl Documentation","title":"Library API Reference","text":"","category":"section"},{"location":"#","page":"Legendre.jl Documentation","title":"Legendre.jl Documentation","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/private.md\"\n]\nDepth = 1","category":"page"},{"location":"#main-index-1","page":"Legendre.jl Documentation","title":"Index","text":"","category":"section"},{"location":"#","page":"Legendre.jl Documentation","title":"Legendre.jl Documentation","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"man/legendre/#man_legendre-1","page":"Legendre Functions","title":"Legendre Polynomials","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"DocTestFilters = Regex[\n        r\"Ptr{0x[0-9a-f]+}\",\n        r\"[0-9\\.]+ seconds( \\(.*\\))?\",\n        ]","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Pages = [\"legendre.md\"]\nDepth = 2","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The Legendre module implementation has been largely based on the approach of Limpanuparb and Milthorpe (2014).","category":"page"},{"location":"man/legendre/#legendre_defn-1","page":"Legendre Functions","title":"Definition and Properties","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The associated Legendre polynomials P_ℓ^m(x) are the solution to the differential equation","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    (1-x^2) fracd^2dx^2P_ℓ^m(x) - 2x fracddxP_ℓ^m(x) + left ℓ(ℓ+1) -\n        fracm^21-x^2 right P_ℓ^m(x) = 0\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"which arises as the colatitude θ part of solving Laplace's equation ^2 ψ + λψ = 0 in spherical coordinates (where x = cos(θ)).","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"There are several different conventions used to define P_ℓ^m that provide different properties, but the convention used here is typical of quantum mechanics and obeys the following properties:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Solutions only exist for integer ℓ and m, where ℓ  0 and m  ℓ.\nThe associated Legendre functions are normalized such that P_0^0 is unity and have orthogonality conditions,\nbeginalign\n    int_-1^1 P_ℓ^m(x) P_ℓ^m(x)mathrmdx\n        = frac22ℓ+1 frac(ℓ+m)(ℓ-m)\n        delta_ℓℓ\nendalign\nfor constant m and\nbeginalign\n    int_-1^1 fracP_ℓ^m(x) P_ℓ^m(x)1-x^2mathrmdx\n        = frac1m frac(ℓ+m)(ℓ-m) delta_mm\nendalign\nfor constant ℓ, where δ is the Kronecker delta.\nThe phase convention for the Legendre functions is chosen such that the negative orders are related to positive orders according to,\nbeginalign\n    P_ℓ^-m(x) = (-1)^m frac(ℓ-m)(ℓ+m) P_ℓ^m(x)\nendalign\nThe Legendre functions can be enumerated for non-negative m using the three following recursion relations (given the initial condition P_0^0(x)):\nbeginalign\n    (ℓ - m + 1)P_ℓ+1^m(x) = (2ℓ+1)xP_ℓ^m(x) - (ℓ+m)P_ℓ-1^m(x)\n    labeleqnstd_rr_2term\n    \n    P_ℓ+1^ℓ+1(x) = -(2ℓ+1)sqrt1-x^2 P_ℓ^ℓ(x)\n    labeleqnstd_rr_1term_lm\n    \n    P_ℓ+1^ℓ(x) = x(2ℓ+1)P_ℓ^ℓ(x)\n    labeleqnstd_rr_1term_l\nendalign","category":"page"},{"location":"man/legendre/#legendre_usage-1","page":"Legendre Functions","title":"Usage","text":"","category":"section"},{"location":"man/legendre/#Calculating-scalar-values-1","page":"Legendre Functions","title":"Calculating scalar values","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"At its simplest, the associated Legendre polynomial P_ℓ^m(x) is computed by calling Legendre.Plm. For example, to compute P_2^1(05),","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> using Legendre\n\njulia> Plm(2, 1, 0.5)\n-1.299038105676658","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"When m = 0 and only the Legendre polynomial P_ℓ(x) is needed, Legendre.Pl can be used instead:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> Plm(2, 0, 0.5)\n-0.125\n\njulia> Pl(2, 0.5)\n-0.125\n\njulia> Pl(2, 0.5) == Plm(2, 0, 0.5)\ntrue","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"In the context of CMB analysis, a common use of the associated Legendre polynomials is to compute the spherical harmonics Y_ℓm(θϕ):","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    beginaligned\n    Y_ℓm(θϕ)  (-1)^m N_ℓ^m P_ℓ^m(cos θ) e^imϕ \n    textwhere  N_ℓ^m  sqrtfrac2ℓ+14π frac(ℓ-m)(ℓ+m)\n    endaligned\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The function Legendre.Nlm calculates the normalization factor N_ℓ^m:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> Nlm(2, 0)\n0.6307831305050401\n\njulia> Nlm(2, 0) * Plm(2, 0, 0.5)\n-0.07884789131313001","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"An important fact about the associated Legendre polynomials is that for m  0, P_ℓ^m(x) diverges to  as ℓ   [1]. For even moderately large pairs of (ℓm), numerical underflow and overflow make computing the spherical harmonics impossible this way:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> n = Nlm(157, 150)      # Underflows\n0.0\n\njulia> p = Plm(157, 150, 0.5) # Overflows\nInf\n\njulia> n * p                  # Undefined\nNaN","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"One way around this would be to just use extended precision arithmetic","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> n = Nlm(BigFloat, 157, 150)\n4.14800666209481424285411223457923933542541063872695815968861285171699012214351e-314\n\njulia> p = Plm(157, 150, big\"0.5\")\n4.768286486602206390406601862422168575170463348990958242752608686436785229641823e+308\n\njulia> Float64(n * p)\n1.9778884113202627e-5","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"but at the expense of much more computationally expensive calculations.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"An alternative way forward is to directly calculate the spherical harmonic normalized associated Legendre polynomials λ_ℓ^m(x) so that the spherical harmonics are defined as","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    beginaligned\n    Y_ℓm(θϕ) = (-1)^m λ_ℓ^m(cos θ) e^imϕ \n     textwhere  λ_ℓ^m(x)  N_ℓ^m P_ℓ^m(x)\n    endaligned\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Legendre.λlm implements this scheme and avoids the under/overflow of computing the normalization separately from the function:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> λlm(157, 150, 0.5)\n1.977888411320258e-5","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"note: Note\nWe are not just limited to efficient and numerically stable computation of λ_ℓ^m(x); the package supports arbitrary normalizations.  For further information on implementing custom Legendre normalizations, see the Custom normalizations section.","category":"page"},{"location":"man/legendre/#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1","page":"Legendre Functions","title":"Calculating all values up to a given ℓ_mathrmmax","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Because calculating a particular Legendre polynomial value is the end result of running a recurrence relation, looping evaluation of P_ℓ^m(x) for all ℓ is inefficient and redoes a lot of work:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> λ = zeros(701);\n\njulia> @time λ[3:701] = [λlm(l, 2, 0.5) for l in 2:700];\n  0.063346 seconds (56.42 k allocations: 2.539 MiB)","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"It's far more efficient to accumulate the intermediate terms while running the recurrence relations. Both of Plm and λlm have modifying counterparts, Plm! and λlm! respectively, which fill an appropriately sized vector for a specified ℓ_mathrmmax.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> @time λlm!(λ, 700, 2, 0.5);\n  0.000162 seconds (14 allocations: 320 bytes)","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"On my machine, this ends up being roughly 400 times faster!","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"If all Legendre polynomial values for some x over all ℓ  0ℓ_mathrmmax and m  0ℓ are required, instead supply an output matrix into which the lower triangle of values is filled:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> Λ = zeros(701, 701);\n\njulia> λlm!(Λ, 700, 700, 0.5);\n\njulia> Λ[701,3] == λlm(700, 2, 0.5)   # N.B. 1-based indexing of the array!\ntrue","category":"page"},{"location":"man/legendre/#Broadcasting-over-multiple-arguments-1","page":"Legendre Functions","title":"Broadcasting over multiple arguments","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The Legendre polynomials can be evaluated over multiple arguments x as well by using Julia's standard broadcasting syntax:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> λlm.(2, 0, range(-1.0, 1.0, length=5))\n5-element Array{Float64,1}:\n  0.63078313050504\n -0.07884789131313\n -0.31539156525252\n -0.07884789131313\n  0.63078313050504","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Broadcasting has been specialized for calls to Pl, Plm, and λlm to avoid the overhead inherent in calling the scalar functions multiple times:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> z = range(-1.0, 1.0, length=500);\n\njulia> @time [λlm(2, 0, i) for i in z];\n  0.054037 seconds (54.23 k allocations: 2.447 MiB)\n\njulia> @time λlm.(2, 0, z);\n  0.000032 seconds (13 allocations: 36.719 KiB)","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"In fact, the shape of z is preserved, so any matrix shape can be used:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> λlm.(2, 0, rand(3,3,3))\n3×3×3 Array{Float64,3}:\n[:, :, 1] =\n  0.326489  -0.285639  -0.313698\n  0.46875   -0.241804  -0.310982\n -0.289767  -0.276217  -0.191519\n\n[:, :, 2] =\n  0.580778   -0.251413   0.091097\n  0.0093121   0.468216  -0.00159624\n -0.0402128  -0.288992   0.397937\n\n[:, :, 3] =\n  0.57083   -0.311711  -0.313631\n  0.242235  -0.197404  -0.247441\n -0.107      0.242107  -0.311164","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Obtaining the Legendre polynomials over multiple ell and/or m values for many arguments can be done via broadcasting as well. The degree l must be a UnitRange starting at zero, and m may be either a scalar integer (to calculate all ell for a fixed m) or a UnitRange starting at zero as well. For example, to compute the P_ell^0(z) and P_ell^2(z) coefficients to an ell_mathrmmax = 700, one could execute","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> summary(Plm.(0:700, 0:2, z))\n\"500×701×3 Array{Float64,3}\"","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The output array will have between 0 and 2 more dimensions more than the dimensionality of the input arguments depending on the calling convention. For scalar values of l and m, the output will be the same shape as z with no extra trailing dimensions. If instead l is a UnitRange, the output dimensionality increases by one, and the trailing dimension runs over the degrees ell; switching to m a UnitRange as well, the output dimensionality is two greater than z, with the penultimate and final dimensions running over ell and m, respectively.","category":"page"},{"location":"man/legendre/#Precomputed-recursion-factors-1","page":"Legendre Functions","title":"Precomputed recursion factors","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"A final trick to accelerating calculation of any normalization of the associated Legendre polynomials is to pre-compute the appropriate recursion relation coefficients.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"At a low level, Plm/Plm! and λlm/λlm! are simple wrappers around the general legendre/legendre! functions. The trait type LegendreUnitNorm dispatches internal functions to compute P_ℓ^m(x):","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> legendre(LegendreUnitNorm(), 5, 2, 0.5) == Plm(5, 2, 0.5)\ntrue","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"and LegendreSphereNorm does the same for λ_ℓ^m(x):","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> legendre(LegendreSphereNorm(), 5, 2, 0.5) == λlm(5, 2, 0.5)\ntrue","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The type LegendreNormCoeff stores the coefficients for a particular normalization (and value type) so that the coefficients must only be calculated once. Aliases for the unit and spherical normalizations are provided by default, LegendreUnitCoeff and LegendreSphereCoeff respectively.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> coeff = LegendreSphereCoeff{Float64}(700);\n\njulia> legendre(coeff, 5, 2, 0.5)\n-0.15888479843070935","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"warning: Performance Note\nChoosing whether to use the pre-computed coefficients or not should be guided by benchmarking and performance profiling. Modern processors can perform many floating point operations in the time it takes to load the coefficients from memory, so depending on the complexity of the normalization, you may actually achieve better performance by recomputing the recursion coefficients on demand.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Notice that due to its flexibility, legendre! requires explicit lmax and mmax arguments even though the LegendreNormCoeff has a lmax and mmax set during construction. This allows us to pass both a coefficient cache and output array which are larger than the computed set of coefficients. For example, the output matrix and cache used above each support computing the Legendre polynomials up to ell = 700, but if we only need ell le 2, we can avoid computing terms beyond our required problem size.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> fill!(Λ, 0);\n\njulia> legendre!(coeff, Λ, 2, 2, 0.5);\n\njulia> Λ[1:5, 1:5]\n5×5 Array{Float64,2}:\n  0.282095    0.0       0.0       0.0  0.0\n  0.244301   -0.299207  0.0       0.0  0.0\n -0.0788479  -0.334523  0.289706  0.0  0.0\n  0.0         0.0       0.0       0.0  0.0\n  0.0         0.0       0.0       0.0  0.0","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"In most situations, though, it'll probably be most convenient to use the functor interface attached to the coefficient cache object which assumes the lmax it was constructed with. The coefficient table itself is callable with forms similar to legendre and legendre! except that the norm and lmax arguments are implicit/not necessary.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> coeff(20, 0.5)    # == legendre(coeff, 20, 0.5)\n-0.08734916334699527\n\njulia> coeff(20, 2, 0.5) # == legendre(coeff, 20, 2, 0.5)\n0.10617507806374693\n\njulia> leg! = coeff;    # alias to clarify that leg! modifies\n\njulia> leg!(λ, 2, 0.5); # same as legendre!(coeff, λ, size(coeff.α, 1) - 1, 2, 0.5)\n\njulia> leg!(Λ, 0.5);    # same as legendre!(coeff, Λ, (size(coeff.α) .- 1)..., 0.5)","category":"page"},{"location":"man/legendre/#legendre_customnorm-1","page":"Legendre Functions","title":"Custom normalizations","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Legendre provides the standard and spherical harmonic normalizations by default, but arbitrary normalizations are also supported. The mile-high overview is that the initial condition and recurrence relation (r.r.) coefficients are all methods which dispatch on a normalization trait type, so a new normalization is added by simply extending appropriate types and methods. The following table lists all of the types to extend and method specialization to implement.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Interfaces to extend/implement Brief description\nLegendre.AbstractLegendreNorm Supertype of normalization trait types\nLegendre.Plm_00() Value of N_0^0 P_0^0(x) for the given normalization\nLegendre.Plm_μ() Coefficient μ_m for the 1-term r.r. boosting ℓ  ℓ+1 and m  m+1\nLegendre.Plm_ν() Coefficient ν_m for the 1-term r.r. boosting ℓ  ℓ+1\nLegendre.Plm_α() Coefficient α_ℓ^m for the 2-term r.r. acting on the (ℓm) term\nLegendre.Plm_β() Coefficient β_ℓ^m for the 2-term r.r. acting on the (ℓ-1m) term","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"As a concrete example, we'll walk through how λ_ℓ^m(x) is defined to have the spherical harmonic normalization baked in.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    λ_ℓ^m(x)  N_ℓ^m P_ℓ^m(x)\n    \n    N_ℓ^m = sqrtfrac2ℓ+14π frac(ℓ-m)(ℓ+m)\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Baking in the normalization happens by changing the coefficients in the recursion relations given in the Definitions and Properties section. For our purposes, they take on the form:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    P_ell+1^m(x) = alpha_ell+1^m x P_ell^m(x)\n        - beta_ell+1^m P_ell-1^m(x)\n        labeleqncus_rr_2term\n    \n    P_m+1^m+1(x) = mu_m+1 sqrt1-x^2 P_m^m(x)\n        labeleqncus_rr_1term_lm\n    \n    P_m+1^m(x) = nu_m x P_m^m(x)\n        labeleqncus_rr_1term_l\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The normalization is encoded in the coefficients α_ℓ^m, β_ℓ^m, μ_m, and ν_m. For the standard (unity) normalization, these take on the values","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    α_ℓ^m = frac2ℓ - 1ℓ - m \n    β_ℓ^m = fracℓ + m - 1ℓ - m \n    μ_m = 2ℓ - 1 \n    ν_m = 2ℓ + 1\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"by simply identifying the coefficients from Eqns. refeqnstd_rr_2term–refeqnstd_rr_1term_l on each of the P_ℓ^m(x) terms on the right hand side. For other normalizations, we multiply through by the normalization factor appropriate for the left-hand side of the equations, rearrange terms to correctly normalize the terms on the right, and identify the coefficients left over. For example, α_ℓ^m and β_ℓ^m for λ_ℓ^m(x) are determined by starting with Eq. refeqnstd_rr_2term and multiply through by N_ℓ+1^m. The left-hand side by definition is λ_ℓ+1^m, leaving us with","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    beginsplit\n        λ_ℓ+1^m = frac2ℓ + 1ℓ - m + 1 x\n            sqrtfrac2ℓ+34π frac(ℓ-m+1)(ℓ+m+1) P_ℓ^m(x) -\n            \n            quadquad fracℓ+mℓ-m+1 sqrtfrac2ℓ+34π\n            frac(ℓ-m+1)(ℓ+m+1) P_ℓ-1^m(x)\n    endsplit\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Through judicious use of algebra, the terms on the right-hand side can be manipulated to gather terms of the form N_ℓ^m P_ℓ^m(x) and N_ℓ-1^m P_ℓ-1^m(x), leaving us with","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    λ_ℓ+1^m = sqrtfrac2ℓ+32ℓ-1 frac4ℓ^2 - 1(ℓ+1)^2 - m^2 x\n        λ_ℓ^m(x) -\n        sqrtfrac2ℓ+32ℓ-1 fracℓ^2 - m^2(ℓ+1)^2 - m^2\n        λ_ℓ-1^m(x)\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"We identify each of the two square root terms as α_ℓ+1^m and β_ℓ+1^m since they are the cofficients appropriate for generating λ_ℓ+1^m(x). Doing so with the other two recurrence relation equations, we obtain:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    α_ℓ^m = sqrtfrac2ℓ+12ℓ-3 frac4(ℓ-1)^2 - 1ℓ^2 - m^2 \n    β_ℓ^m = sqrtfrac2ℓ+12ℓ-3 frac(ℓ-1)^2 - m^2ℓ^2 - m^2 \n    μ_m = sqrt1 + frac12m \n    ν_m = sqrt2m + 3\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The final math required is to define the initial condition λ_0^0(x). This is straight forward given the definition:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"beginalign\n    λ_0^0(x) = N_0^0 P_0^0(x) = sqrtfrac14π  1 \n    λ_0^0(x) = sqrtfrac14π\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"We now have all the information required to define a custom Legendre normalization. Begin by importing the types and methods which will need to be extended:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> using Legendre\n\njulia> import Legendre: AbstractLegendreNorm, Plm_00, Plm_μ, Plm_ν, Plm_α, Plm_β","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"We'll call our new normalization λNorm, which must be a subclass of AbstractLegendreNorm.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> struct λNorm <: AbstractLegendreNorm end","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"The initial condition is specified by providing a method of Plm_00 which takes our normalization trait type as the first argument. (The second argument can be useful if some extra type information is required to set up a type-stable algorithm, which we'll ignore here for the sake of simplicity.)","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> Plm_00(::λNorm, T::Type) = sqrt(1 / 4π)\nPlm_00 (generic function with 4 methods)","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"Finally, we provide methods which encode the cofficients as well:","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> function Plm_α(::λNorm, T::Type, l::Integer, m::Integer)\n           fac1 = (2l + 1) / ((2l - 3) * (l^2 - m^2))\n           fac2 = 4*(l-1)^2 - 1\n           return sqrt(fac1 * fac2)\n       end\nPlm_α (generic function with 4 methods)\n\njulia> function Plm_β(::λNorm, T::Type, l::Integer, m::Integer)\n           fac1 = (2l + 1) / ((2l - 3) * (l^2 - m^2))\n           fac2 = (l-1)^2 - m^2\n           return sqrt(fac1 * fac2)\n       end\nPlm_β (generic function with 4 methods)\n\njulia> Plm_μ(::λNorm, T::Type, m::Integer) = sqrt(1 + 1 / 2m)\nPlm_μ (generic function with 4 methods)\n\njulia> Plm_ν(::λNorm, T::Type, m::Integer) = sqrt(3 + 2m)\nPlm_ν (generic function with 4 methods)","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"With just those 5 methods provided, the full Legendre framework is available, including precomputing the coefficients.","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"julia> legendre(λNorm(), 700, 500, 0.4)\n0.35366224602811\n\njulia> coeff = LegendreNormCoeff{λNorm,Float64}(700);\n\njulia> legendre(coeff, 700, 500, 0.4)\n0.35366224602811","category":"page"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"","category":"page"},{"location":"man/legendre/#Footnotes-1","page":"Legendre Functions","title":"Footnotes","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Functions","title":"Legendre Functions","text":"[1]: Specifically, the envelope of P_ℓ^m(x) which bounds the local extrema for all values of x can be shown to be    left P_ℓ^m(cos θ) right  fracΓ(ℓ+m+1)Γ(ℓ+frac32)\n        left( frac2π sin θ right)^12(see Eq. 8.10.7 (p336) of Abramowitz and Stegun, “Handbook of Mathematical Functions” 10th printing (1972)). For fixed m and any x, we take the asymptotic limit as ℓ   and simplify Γ(z) via Stirling's approximation to get the scaling of the associated Legendre polynomial envelope    DeclareMathOperator*envenv\n    env_ℓleft( P_ℓ^m right)  ℓ^m - 12 text In contrast, the normalization factor N_ℓ^m scales as ℓ^12 - m, exactly canceling the scaling of envleft(P_ℓ^mright), so overall the spherical harmonic normalized Legendre polynomials λ_ℓ^m(x) asymptote to some constant envelope:    env_ℓ left( λ_ℓ^m right)  ℓ^0 = textconstant ","category":"page"}]
}
